# **Java Exception Handling – try, catch**

## ⭐ **What is Exception Handling?**

Exception handling in Java is a mechanism that allows developers to **detect, handle, and recover from runtime errors** without terminating the entire program.

It helps maintain **normal program flow** even when unexpected situations occur (e.g., dividing by zero, file not found).

---

# ⭐ **Why Exception Handling?**

Without exception handling:

* The exception is thrown to the **JVM**
* JVM **abnormally terminates** the program
* Remaining code **does NOT execute**

With exception handling:

* The exception is **caught and handled**
* JVM does **not terminate the program**
* Remaining statements **execute normally**

---

# ⭐ **try–catch Block (Basic Syntax)**

```java
try {
    // Code that may throw an exception
} catch (ExceptionType1 e1) {
    // Handle specific exception type
} catch (ExceptionType2 e2) {
    // Handle another exception type
} finally {
    // Optional: runs whether exception occurs or not
}
```

In this note, we focus on **try with a single catch block**.

---

# ⭐ **Example: Handling Exception Using try–catch**

```java
// try to handle the exception
class Main {
    public static void main(String[] args) {

        int i = 4; // normal statement

        try {
            int a = 10 / 0; // critical statement

            /*
             If you do not handle this exception,
             JVM will terminate the program abnormally and
             the remaining statements will NOT execute.
            */

            /*
             If you handle the exception,
             it will NOT be thrown to the JVM,
             and the program continues normally.
            */

        } catch (Exception e) {
            System.out.println("Some exception occurred");
        }

        System.out.println("We are coming out of the try-catch block successfully");
    }
}
```

### ✔ **Explanation**

* The line `int a = 10/0;` causes an **ArithmeticException**.
* The catch block handles the exception.
* The last print statement runs successfully because the program does NOT crash.

---

# ⭐ **Types of Statements in Exception Handling**

Java statements can be divided into two types:

---

## **1️⃣ Normal Statements**

These statements:

* Do NOT need special handling
* Execute in normal sequence
* Do NOT cause exceptions (usually)

**Examples**

* Variable declarations
* Assignments
* Print statements

Example:

```java
int x = 10;
System.out.println("Hello");
```

---

## **2️⃣ Critical Statements**

These statements:

* MAY cause an exception at runtime
* Need **special handling**
* Should be placed inside a `try` block

**Examples**

* Division operations
* File handling
* Array operations
* Database/Network calls

Critical statements can be handled using:

* `try-catch`
* `throw`
* `finally`

Example:

```java
int result = 10 / 0; // may throw ArithmeticException
```

---

# ⭐ **Summary (For Placements)**

* `try` block contains **risk/critical** code.
* `catch` block **handles** the exception.
* `finally` block runs **always**, even if exception occurs.
* Without handling, JVM **abnormally terminates** the program.
* Normal statements → safe statements
* Critical statements → may cause exceptions and must be handled.

---


Below is a **clean, structured, placement-ready, README-friendly explanation** of your content.
This version is polished for interviews, GitHub notes, or quick revision.

---


# **Java Exception Handling – Multiple Catch Blocks (Placement Notes)**

## ⭐ **Why do we use multiple catch blocks?**

Sometimes, we write several lines of code inside a `try` block, and we **don’t know which line may throw an exception**, BUT we do know the possible **types of exceptions** that might occur.

To handle different exception types separately, Java allows us to use **multiple catch blocks**.

---

# ⭐ **Example: Handling Multiple Exceptions**

```java
int num = 4;
int arr[] = {3, 4, 5};

try {
    int result = 40 / num;  
    // This may throw ArithmeticException if num = 0

    System.out.println(arr[result]);
    // This may throw ArrayIndexOutOfBoundsException 
    // because valid index range is 0 to 2
}
catch (ArithmeticException ae) {
    System.out.println(ae);
}
catch (ArrayIndexOutOfBoundsException aio) {
    System.out.println(aio);
}
```

### ✔ Explanation

* The `try` block contains **critical statements** that may throw exceptions.
* If division fails → `ArithmeticException` block is executed.
* If invalid array index is accessed → `ArrayIndexOutOfBoundsException` block executes.
* Only **one** catch block executes per exception.

---

# ⭐ **Parent and Child Exceptions – Important Interview Concept**

Java has an **exception hierarchy**, where:

* `Exception` is the **parent**
* Classes like `ArithmeticException`, `ArrayIndexOutOfBoundsException` are **child exceptions**

When using multiple catch blocks:

### ❗ **Always catch child exceptions BEFORE the parent exception.**

If you catch the parent (`Exception`) first:

* It will catch *all* child exceptions
* Child catch blocks will **never execute**
* Compiler will report an error

---

# ❌ **Wrong Order (Will Cause Compile-Time Error)**

```java
int a = 10;
int arr[] = {3, 4, 5};

try {
    int b = 3 / a;
    System.out.println(arr[b]);
}
catch (Exception e) {  
    System.out.println("parent class of every exception");
}
catch (ArithmeticException e) {  
    // ❌ Compile-time error
}
```

### ✔ Compiler Error:

```
error: exception ArithmeticException has already been caught
```

Reason:
`Exception` (parent class) catches everything first → child catch block becomes unreachable.

---

# ✅ **Correct Order (Child First, Parent Last)**

```java
int a = 10;
int arr[] = {3, 4, 5};

try {
    int b = 3 / a;
    System.out.println(arr[b]);
}
catch (ArithmeticException e) {  
    // Child exception
}
catch (Exception e) {  
    // Parent exception
    System.out.println("parent class of every exception");
}
```

### ✔ Explanation:

* Child exceptions must be caught first.
* Parent exception is kept **last** as a fallback/default handler.
* This structure avoids compile-time errors and handles exceptions correctly.

---

# ⭐ **Key Notes (Placement-Important)**

* Multiple catch blocks help handle **different exceptions separately**.
* Catch blocks run **top to bottom** → first match wins.
* **Child exceptions must be caught before parent exceptions**.
* If parent comes first → compiler error: *“exception already caught”*
* Only **one catch block** executes per thrown exception.

---


